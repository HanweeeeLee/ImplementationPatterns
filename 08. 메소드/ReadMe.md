# 08. 메소드
프로그램 로직을 여러 개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다. 메소드를 클래스로 나누고, 클래스를 패키지로 나누면, 더 많은 정보를 전달하게 된다. 메소드 이름을 통해 독자는 실제 세부 구현과 상관 없이 로직의 목적이 무엇인지 알 수 있다.  
또한 메소드를 사용하면 재사용 문제를 해결할 수 있다.  
프로그램을 메소드로 나누는 데 신경써야 할 요소로는 메소드의 크기, 목적, 이름등이 있다.  
메소드 관련 패턴은 다음과 같다.  
 - 조합 메소드: 다른 메소드에 대한 호출로 메소드를 작성한다. 
 - 의도 제시형 이름: 멧드가 의도하는 바를 나타내는 이름을 사용한다.
 - 메소드 가시성: 메소드는 가급적 전용으로 한다. 
 - 메소드 객체: 복잡한 메소드는 새로운 객체로 바꾼다. 
 - 오버라이드 메소드: 특화를 나타내기 위해 오버라이드를 사용한다.
 - 오버로드 메소드: 같은 연산에 대해 다른 인터페이스를 제공한다. 
 - 메소드 반환 타입: 반환 타입에는 가급적 가장 일반적인 타입을 사용
 - 메소드 주석: 코드 자체에서 쉽게 얻을수 없는 정보는 주석을 통해 나타냄
 - 도우미 메소드: 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용
 - 디버그 출력 메소드: toString()을 사용해서 유용한 디버그 관련 정보를 출력
 - 변환: 객체 형변환은 명확하게 표현
 - 변환 메소드: 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공
 - 변환 생성자: 대부분의 변환에 대해서는 원복 객체를 인자로 취하는 변환될 객체의 생성자를 제공
 - 생성: 객체 생성을 명확히 표현
 - 완결 생성자: 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
 - 공장 메소드: 좀더 복잡한 객체를 생성할 때 생성자 대신 정적 메소드를 사용
 - 내부 공장: 좀더 많은 설명이 필요하거나 이후 개선이 필요 한 객체의 생성의 경우 도우미 메소드로 캡슐화 한다.
 - 컬렉션 접근자 메소드: 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공
 - 불린 설정 메소드: 커뮤니케이션에 도움이 된다면, 불린 값을 설정하는 두개의 메소드를 제공
 - 쿼리 메소드: isXXX라는 이름으로 된 메소드를 사용해서 불린 값을 반환
 - 동등성 메소드: equals와 hashcode를 함께 정의
 - 취득 메소드: 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공
 - 설정 메소드: 드물게 메소드를 사용해서 필드 값을 설정.
 - 안전한 복사: 접근자 메소드를 통해 전달하거나 전달 되는 인스턴스를 복사해서 엘리어스 문제를 회피

## 조합 메소드
추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라. 잘못 구성된 메소드는 상이한 추상화 수준의 메소드를 호출한다.
```Java
void compute() {
	input();
	flags|= 0x0080; // 이 비트는 무엇을 의미할까 를 생각하게 된다. 
	output();
}
```
성능을 위해 메소드는 5-15줄 이내로 작성해야한다?? 아니면 알맞은 메소드 길이는?  
짧은 메소드 단위로 코드를 구성할때 확실히 이해하기는 쉬워진다.  
메소드를 구성할 때는 추측이 아닌 사실에 근거하라. 일단 동작하는 코드를 만들고 구성 방식을 결정하자. 코드 구성에 미리 시간을 들이게 되면, 나중에 어짜피 수정됨..  

## 의도 제시형 이름
메소드 사용자는 메소드 이름을 통해 메소드의 의도를 쉽게 파악할 수 있어야한다.  
```Java
Customer.linearCustomerSearch(String id)
```
->
```Java
Customer.find(String id)
```
> 구현 전략이 사용자에게는 중요하지 않다. 빼자..  
  
ex2)
```Java
Customer.find(String id)
Customer.fastFind(String id)
```
> fastFind를 해시맵을 이용했는지 뭘 이용했는지는 중요하지 않다. 
  
기존 인터페이스에 대한 유사점을 사용해서 메소드를 구현한다면 인터페이스에 사용된 것과 같은 이름을 사용하자.  
ex) 
실제 iterator 인터페이스를 구현하는 것이 아니라 할지라도 Iterator 인터페이스를 본따서 hasNext()나 next()와 같은 메소드 이름을 사용하자.  


## 메소드 가시성
네 가지 수준(public, package, protected, private)의 메소드 가시성 역시 프로그래머의 의도를 전달한다.  
메소드 가시성에 있어 상충하는 두 가지 주요 요소는 외부 사용자에게 기능을 노출시켜야 하는것과 미래 수정에 대한 유연성이다.  
더 많은 메소드를 노출시킬수록 객체에 대한 인터페이스를 수정하기는 어려워진다.  
  
가시성을 선택할 때는 두 가지 비용을 고려해야한다.  
### 미래의 유연성
외부에 드러나는 인터페이스가 많지 않은 경우 미래에 인터페이스를 수정하는것은 어렵지 않다.  
### 들어가는 비용
노출된 인터페이스가 많지 않은 객체를 사용할 경우, 사용하는 측에서 필요 이상으로 많은 작업을 해야한다.  
  
 - public: 패키지 외부에서도 이메소드가 유용한것이라고 이야기하는것 메소드를 수정할때 본인이 모두 담당하거나, 최소한 사용자들에게 수정 사항을 알려줄 책임이 있다.
 - package: 패키지 가시성은 해당 메소드가 같은 패키지의 다른 객체에는 유용하지만 패키지 외부의 객체에는 공개하지 않겠다.
 - protected: 하위 클래스를 사용해서 코드를 재사용할때 유용
 - private: 외부 객체와 상관 없이 모든 메소드 호출을 제어할 수 있다는 점에서 전용 메소드는 최고의 유연성을 확보해준다.

먼저 가장 제한적인 가시성을 선택한 후, 필요에 따라 조금씩 가시성을 높여라. 반면 만약 어떤 메소드의 가시성이 불필요하게 높다면 가시성을 낮춰라.  
메소드를 final로 선언하는 문제는 가시성을 선택하는 문제와 비슷하다.  
메소드를 static으로 선언하면 다른 객체에서 해당 클래스의 인스턴스에 접근할 수 없는 경우에도 메소드에 접근할 수 있다. 정적 메소드는 어떤 인스턴스의 상태에 의존할 수 없으므로 복잡한 로직을 구현하기에 적합하지 않다.  

## 메소드 객체
메소드 객체는 복잡하게 꼬여있는 메소드를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다.  
메소드 객체를 생성할 때는 먼저 많은 수의 파라미터와 임시 변수를 사용하는 긴메소드를 찾아보라. 메소드를 찾았다면 해당 메소드의 일부를 많은 파라미터를 사용하는 서브 메소드로 변환한다. 메소드 객체를 생성하는 순서는 다음과 같다.  
  
1. 메소드 이름을 따서 클래스 이름을 정한다. 예를 들어 complexCalculation()은 ComplexCalculator가 된다.
2. 메소드에서 사용하는 각 파라미터, 지역변수, 필드에 대해 새로운 객체상의 필드를 생성한다. 일단 기존에 사용한 이름과 같은 이름을 사용한다.
3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다. 
4. 본래 메소드를 새로운 클래스의 calculate()라는 메소드로 복사한다. 기존 메소드에서 파라미터, 지역변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 되었다.
5. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다. 예를 들면 다음과 같다.
```Java
complexCalculation() {
	new complexCalculator().calculate();
}
```
6. 본래 메소드에서 필드를 설정하는 부분이 있다면, 다음과 같이 calculate()가 반환된 후에 설정해준다. 
```Java
complexCalculation() {
	ComplexCalculator calculator = new ComplexCalculator();
	calculator.calculate();
	mean = calculator.mean;
	variance = calculator.variance;
}
```
리팩토링 된 코드가 기존 코드와 똑같이 동작하는지 확인한다.  
-> 필요했던 파라미터가 클래스 내부로 들어가서 생성자에 넣거나 그렇게 변하는 경우가 상당히 많음































