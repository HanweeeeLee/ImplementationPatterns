# 08. 메소드
프로그램 로직을 여러 개의 메소드로 나누면 로직 간의 연관성을 나타낼 수 있다. 메소드를 클래스로 나누고, 클래스를 패키지로 나누면, 더 많은 정보를 전달하게 된다. 메소드 이름을 통해 독자는 실제 세부 구현과 상관 없이 로직의 목적이 무엇인지 알 수 있다.  
또한 메소드를 사용하면 재사용 문제를 해결할 수 있다.  
프로그램을 메소드로 나누는 데 신경써야 할 요소로는 메소드의 크기, 목적, 이름등이 있다.  
메소드 관련 패턴은 다음과 같다.  
 - 조합 메소드: 다른 메소드에 대한 호출로 메소드를 작성한다. 
 - 의도 제시형 이름: 멧드가 의도하는 바를 나타내는 이름을 사용한다.
 - 메소드 가시성: 메소드는 가급적 전용으로 한다. 
 - 메소드 객체: 복잡한 메소드는 새로운 객체로 바꾼다. 
 - 오버라이드 메소드: 특화를 나타내기 위해 오버라이드를 사용한다.
 - 오버로드 메소드: 같은 연산에 대해 다른 인터페이스를 제공한다. 
 - 메소드 반환 타입: 반환 타입에는 가급적 가장 일반적인 타입을 사용
 - 메소드 주석: 코드 자체에서 쉽게 얻을수 없는 정보는 주석을 통해 나타냄
 - 도우미 메소드: 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용
 - 디버그 출력 메소드: toString()을 사용해서 유용한 디버그 관련 정보를 출력
 - 변환: 객체 형변환은 명확하게 표현
 - 변환 메소드: 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공
 - 변환 생성자: 대부분의 변환에 대해서는 원복 객체를 인자로 취하는 변환될 객체의 생성자를 제공
 - 생성: 객체 생성을 명확히 표현
 - 완결 생성자: 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
 - 공장 메소드: 좀더 복잡한 객체를 생성할 때 생성자 대신 정적 메소드를 사용
 - 내부 공장: 좀더 많은 설명이 필요하거나 이후 개선이 필요 한 객체의 생성의 경우 도우미 메소드로 캡슐화 한다.
 - 컬렉션 접근자 메소드: 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공
 - 불린 설정 메소드: 커뮤니케이션에 도움이 된다면, 불린 값을 설정하는 두개의 메소드를 제공
 - 쿼리 메소드: isXXX라는 이름으로 된 메소드를 사용해서 불린 값을 반환
 - 동등성 메소드: equals와 hashcode를 함께 정의
 - 취득 메소드: 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공
 - 설정 메소드: 드물게 메소드를 사용해서 필드 값을 설정.
 - 안전한 복사: 접근자 메소드를 통해 전달하거나 전달 되는 인스턴스를 복사해서 엘리어스 문제를 회피

## 조합 메소드
추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라. 잘못 구성된 메소드는 상이한 추상화 수준의 메소드를 호출한다.
```Java
void compute() {
	input();
	flags|= 0x0080; // 이 비트는 무엇을 의미할까 를 생각하게 된다. 
	output();
}
```
성능을 위해 메소드는 5-15줄 이내로 작성해야한다?? 아니면 알맞은 메소드 길이는?  
짧은 메소드 단위로 코드를 구성할때 확실히 이해하기는 쉬워진다.  
메소드를 구성할 때는 추측이 아닌 사실에 근거하라. 일단 동작하는 코드를 만들고 구성 방식을 결정하자. 코드 구성에 미리 시간을 들이게 되면, 나중에 어짜피 수정됨..  

## 의도 제시형 이름
메소드 사용자는 메소드 이름을 통해 메소드의 의도를 쉽게 파악할 수 있어야한다.  
```Java
Customer.linearCustomerSearch(String id)
```
->
```Java
Customer.find(String id)
```
> 구현 전략이 사용자에게는 중요하지 않다. 빼자..  
  
ex2)
```Java
Customer.find(String id)
Customer.fastFind(String id)
```
> fastFind를 해시맵을 이용했는지 뭘 이용했는지는 중요하지 않다. 
  
기존 인터페이스에 대한 유사점을 사용해서 메소드를 구현한다면 인터페이스에 사용된 것과 같은 이름을 사용하자.  
ex) 
실제 iterator 인터페이스를 구현하는 것이 아니라 할지라도 Iterator 인터페이스를 본따서 hasNext()나 next()와 같은 메소드 이름을 사용하자.  


## 메소드 가시성
네 가지 수준(public, package, protected, private)의 메소드 가시성 역시 프로그래머의 의도를 전달한다.  
메소드 가시성에 있어 상충하는 두 가지 주요 요소는 외부 사용자에게 기능을 노출시켜야 하는것과 미래 수정에 대한 유연성이다.  
더 많은 메소드를 노출시킬수록 객체에 대한 인터페이스를 수정하기는 어려워진다.  
  
가시성을 선택할 때는 두 가지 비용을 고려해야한다.  
### 미래의 유연성
외부에 드러나는 인터페이스가 많지 않은 경우 미래에 인터페이스를 수정하는것은 어렵지 않다.  
### 들어가는 비용
노출된 인터페이스가 많지 않은 객체를 사용할 경우, 사용하는 측에서 필요 이상으로 많은 작업을 해야한다.  
  
 - public: 패키지 외부에서도 이메소드가 유용한것이라고 이야기하는것 메소드를 수정할때 본인이 모두 담당하거나, 최소한 사용자들에게 수정 사항을 알려줄 책임이 있다.
 - package: 패키지 가시성은 해당 메소드가 같은 패키지의 다른 객체에는 유용하지만 패키지 외부의 객체에는 공개하지 않겠다.
 - protected: 하위 클래스를 사용해서 코드를 재사용할때 유용
 - private: 외부 객체와 상관 없이 모든 메소드 호출을 제어할 수 있다는 점에서 전용 메소드는 최고의 유연성을 확보해준다.

먼저 가장 제한적인 가시성을 선택한 후, 필요에 따라 조금씩 가시성을 높여라. 반면 만약 어떤 메소드의 가시성이 불필요하게 높다면 가시성을 낮춰라.  
메소드를 final로 선언하는 문제는 가시성을 선택하는 문제와 비슷하다.  
메소드를 static으로 선언하면 다른 객체에서 해당 클래스의 인스턴스에 접근할 수 없는 경우에도 메소드에 접근할 수 있다. 정적 메소드는 어떤 인스턴스의 상태에 의존할 수 없으므로 복잡한 로직을 구현하기에 적합하지 않다.  

## 메소드 객체
메소드 객체는 복잡하게 꼬여있는 메소드를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다.  
메소드 객체를 생성할 때는 먼저 많은 수의 파라미터와 임시 변수를 사용하는 긴메소드를 찾아보라. 메소드를 찾았다면 해당 메소드의 일부를 많은 파라미터를 사용하는 서브 메소드로 변환한다. 메소드 객체를 생성하는 순서는 다음과 같다.  
  
1. 메소드 이름을 따서 클래스 이름을 정한다. 예를 들어 complexCalculation()은 ComplexCalculator가 된다.
2. 메소드에서 사용하는 각 파라미터, 지역변수, 필드에 대해 새로운 객체상의 필드를 생성한다. 일단 기존에 사용한 이름과 같은 이름을 사용한다.
3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다. 
4. 본래 메소드를 새로운 클래스의 calculate()라는 메소드로 복사한다. 기존 메소드에서 파라미터, 지역변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 되었다.
5. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 calculate()를 호출하는 코드로 바꾼다. 예를 들면 다음과 같다.
```Java
complexCalculation() {
	new complexCalculator().calculate();
}
```
6. 본래 메소드에서 필드를 설정하는 부분이 있다면, 다음과 같이 calculate()가 반환된 후에 설정해준다. 
```Java
complexCalculation() {
	ComplexCalculator calculator = new ComplexCalculator();
	calculator.calculate();
	mean = calculator.mean;
	variance = calculator.variance;
}
```
리팩토링 된 코드가 기존 코드와 똑같이 동작하는지 확인한다.  
-> 필요했던 파라미터가 클래스 내부로 들어가서 생성자에 넣거나 그렇게 변하는 경우가 상당히 많음

## 오버라이드
오버라이드를 사용하면 변형 메소드를 명확하게 표현할 수 있다.  
오버라이드를 사용한다고 상위 클래스와 하위 클래스의 메소드 중 하나를 선택해야만 하는 것은 아니다. super.method()를 사용해주면 됨.  
하나의 메소드에서 여러 상위클래스 메소드를 호출해야 하는 경우라면, 제어 흐름을 재구성해서 더 이상 하위 클래스와 상위 클래스 사이에서 오가지 말도록 하자. 헷갈림  
너무 방대한 상위 클래스를 가지게 되는경우 모르는 새에 누군가가 상위 클래스의 메소드를 수정하게되면 하위 클래스에 문제가 생길 수 있다.  

## 오버로드 
서로 다른 파라미터를 사용해서 같은 메소드를 선언  
메소드로 오버로드를 사용하면 호출자가 특정 파라미터 형태로 객체를 변형해야 하는 부담을 덜어준다.  
오버로드가 너무 복잡해지면 독자는 어떤 인자를 사용했을 때 어떤 메소드가 호출될지 알기 위해 오버로드 규칙에 대해 알아야 한다. (문제점)  
메소드 오버로드는 파라미터 타입만 다를 뿐, 같은 연산을 수행해야 한다.  

## 메소드 반환 타입
함수를 작성할 떄는 의도를 나타내는 반환 타입을 사용하라.  
콘크리트 클래스나 기본타입을 반환타입으로 사용할 수도 있겠지만, 가급적 메소드 적용 범위를 넓히기 위해서 의도를 드러낼 수 있는 가장 추상적인 타입을 사용하자.  
반환 타입을 일반화하면 세부 구현을 숨길 수도 있다.  

## 메소드 주석
프로그래머는 코드의 이름과 구조를 통해 최대한 많은 정보를 전달하는것이 좋다. 하지만 코드만으로 분명하지 않은 정보는 주석을 사용해 전달하라. 필요한 경우 자바독 사용까지 고려하셈  
많은 경우 주석은 이미 알 수 있는 정보를 중복해서 나타낼 뿐, 실제 커뮤니케이션에 도움을 주지 못한다. 주석을 작성하고 코드와 주석 간 일관성을 유지하기 위해서는 노력이 많이 든다. 따라서 정당성이 있을때에만 주석을 쓰자.  
  
자동화된 테스트를 사용하면 메소드 주석으로 표현할 수 없는 내용을 전달할 수 있다.  
정해진 순서대로 실행되어야 하는 메소드가 만약 잘못된 순서로 호출되면 예외가 발생하는지 테스트하는 프로그램을 예로 들 수 있다.  
좋은 주석을 작성하자.  

## 도우미 메소드 
조합 메소드를 사용하다보면 메소드가 필요해진다. 긴 메소드를 여러 개의 작은 메소드로 나누게 되면 짧은 도우미 메소드가 필요하다.  
도우미 메소드의 목적은 당장 관련도가 떨어지는 세부 구현을 숨기고 메소드 이름을 통해 프로그래머의 의도를 나타냄으로써, 거대한 코드를 좀 더 읽기 좋게 만들어주기 위함이다.  
  
도우미 메소드는 보통 짧지만, 어떤 경우에는 아주 짧을 수도 있다. 
```Java
return testClass.getConstructor().newInstance();
```
커뮤니케이션 관점에서 볼 떄 위 코드는 다음 코드와 크게 다르지 않다.
```Java
return getTestConstructor().newInstance();
```
하지만 하위클래스에서 생성자를 오버라이드하는 경우, 이러한 도우미 메소드를 사용하는 것은 정당화될 수 있다.  
  
메소드의 로직이 불명확해지는 경우에는 도우미 메소드를 (최소한 일시적으로라도) 제거하라. 모든 도우미 메소드를 인라인하고 새로운 시각에서 로직을 바라본 후, 자연스러운 방향으로 메소드를 분리하라.  
  
도우미 메소드의 마지막 목적은 공용구문(common sub-expression)을 제거하는 것이다.  
조그마한 특정 연산이 필요할 경우마다 도우미 메소드를 호출하면 해당 구문의 수정은 어렵지 않다.  
하지만 같은 2-3줄의 코드가 필요한 경우마다 반복된다면, 잘 선택한 이름을 통해 프로그래머의 의도를 부각시킬 수 없을 뿐 아니라 코드 수정도 어려워진다.(도우미 메소드 안에 반복되는 코드를 넣거나, 새로운 도우미 메소드를 생성하라는 뜻인가..?)

## 디버그 출력 메소드
객체를 문자열로 나타내면 어떤 객체의 내용을 사용자에게 표현할 때 편리하고, 저장후 다시 읽어와서 사용하기에도 좋으며, 프로그래머에게 객체의 내부 구현을 표현할 수도 있다.  
고품질의 디버그 메시지를 출력하면 얻을 수 있는 장점이 많다. toString()같은 메서드로 출력하는것,..?  
(런타임 디버그 할 때 toString()같은 메소드 있다면 편하다는 뜻인가? ㅡ,.ㅡ)  

## 변환 
떄로 객체 A를 가진 상태에서 이후 연산을 위해 객체 B가 필요한 경우가 있다.  
다른 패턴들과 마찬가지로 변환 패턴의 목표는 프로그래머의 의도를 명확히 전달하는 것이다. 이를 위해서는 몇 가지 고려사항이 필요함.  
1. 변환이 얼마나 많이 필요한지 생각해야한다. 하나의 객체가 다른 하나의 객체로 변환되는것이면 간단하게 해도 되는데 복잡하면 다른 방법을 찾아야함
2. 클래스 간의 의존성이 생길 수 있으므로 잘 생각하고 변환하자.
  
변환의 구현은 완전히 다른 문제다.  
어떤 경우는 기존 객체의 정보를 복사해서 새로운 타입의 실제 객체를 생성하고,  
어떤 경우는 정보를 복사하지 않고 대상 객체에 대한 인터페이스를 구현할 수도 있다.  

## 변환 메소드 

유사한 타입의 객체 간 변환을 표현하려 하고 필요한 변환의 수에 제한이 있다면, 기존 객체에 메소드를 추가해서 변환을 나타낼 수 있다.

```Java
class Polar {
	// 일반 좌표와 극좌표를 구현
	Cartesian asCartesian() {
		...
	}
}
```
> 변환 메소드의 반환 타입이 대생 각체임에 주목하자. 변환을 사용하는 이유는 다른 프로토콜을 사용하는 객체를 얻기 위함이다.  
  
변환 메소드는 읽기 쉽다는 장점때문에 많이 사용되지만 하나의 변환 메소드를 만들기 위해서는 원본 객체의 프로토콜을 뼌경해야한다.  
또한 변환 메소드는 원본 객체와 대상 객체 사이에서 의존성을 생성한다.  
마지막으로 변환 객체는 필요한 변환의 수가 제한되지 않는 경우 다루기 어려워진다.  
이러한 단점들로 인해 변환 메소드는 자주 사용되지 않으며, 유사한 타입의 객체 사이변환에만 사용됨. 대부분 변환 메소드보다 변환 생성자를 사용함.

## 변환 생성자
변환 생성자는 원본 객체를 파라미터로 취해서 대상 객체를 반환한다.  
```Swift 
class Caresian {
	init(polar: Polar) {
		...
	}
}
```

## 생성
프로그램은 실제 수행되는 만큼 자주 수정되기도 한다.  
규칙 없는 제어 흐름 이동, 자가 수정 코드, 제한 없는 데이터 접근 등은 프로그램 수행에는 편리하지만 프로그램 수정은 너무 힘들어진다.  
크기가 작은 프로그램은 큰 프로그램에 비해서 수정하기 쉽다. 따라서 프로그램 수정을 쉽게 하기 위한 초기 전략은 커다란 프로그램을 수행하는 하나의 컴퓨터를 더 작은 프로그램을 수행하는 여러 개의 컴퓨터(객체)로 나누는 것이다.  
## 완결 생성자
객체는 연산을 하기 위해 정보를 필요로 한다. 생성자에서 연산을 할 수 있는 객체를 반환하도록 해서, 잠재적 사용자들에게 연산을 위한 선결 조건을 전달하라. 객체를 설정하는 방법이 여러 가지라면, 각 경우마다 제대로 된 객체를 반환하는 생성자를 제공하라.  

```Java
Rectangle box = new Rectangle();
box.setLeft(0);
box.setWidth(50);
box.setHeight(200);
box.setTop(0);
```
> 유연하긴 하지만(?) 어떤 값이 required고 optional인지 판단할 수 없다.
```Java
new Rectangle(0, 0, 50, 200);
```
> 생성자를 통해 required값을 지정하자.

## 공장 메소드
객체 생성을 나타내는 다른 방법은 클래스의 정적 메소드를 사용하는 것이다.  
정적 메소드가 생성자보다 더 좋은점은?
 - 추상 타입 반환 가능
 - 의도가 담긴 별도의 이름을 가질 수 있음  
  
단점
 - 복잡성 증가  

```Java
Rectangle.create(0, 0, 50, 200);
```
객체를 생성하는 것보다 복잡한 작업(예: 객체를 캐쉬에 저장해 놓거나, 런타임에 타입이 결정되는 하위클래스를 반환하거나 등)을 하는 경우 유용하다.  
그러나 코드를 읽을 때, 공장 메소드를 볼 떄마다 객체 생성 이외에 어떤 작업이 일어나는가 하는 의문을 갖게 된다. 꼭 필요한 곳에 사용하자.  

## 내부 공장
도우메 객체 생성을 전용으로 하고 싶지만, 객체 생성 과정이 복잡하거나 하위 클래스에 따라 달라질 경우엔? 새로운 객체를 생성하고 반환하는 메소드를 만들자.  
```Java
getX() {
	if (x == null)
		x = ...;
	return x;
}
```
> 게으른 초기화를 사용해 변수를 초기화  
-> 이 코드는 너무 많은 내용을 전달한다. 변수 x에 대한 연산이 복잡한 경우에는 내부 공장을 사용하는 편이 낫다. 
```Java
getX() {
	if (x == null)
		x = computeX();
	return x;
}
```

## 컬렉션 접근자 메소드
컬렉션을 갖고 있는 객체가 있다고 해보자. 컬렉션에 대한 접근을 어떻게 제공해야 할까? 가장 간단한 방법은 컬렉션을 반환하는 취득 메소드를 제공하는 것이다. 
```Java
List<Book> getBooks() {
	return books;
}
```
> 사용자는 최대의 유연성을 얻게 되지만 문제점이 몇 가지 생긴다.  
  
단점: 
 - 사용자가 컬렉션을 직접 조작하게 되므로, 컬렉션 데이터에 의존적인 객체 내부 상태가 유효하지 않게 될 수 있다. 
 - 컬렉션을 직접 반환해서 모든 작업을 허용하면, 해당 객체에 대한 풍부하고 의미 있는 프로토콜을 만들 기회를 상실하게 된다. 
  
한 가지 해법은 컬렉션을 반환하기 전에 수정할 수 없는 컬렉션 형태로 바꿔서 반환하는 것이다. 
```Java
List<Book> getBooks() {
	return Collections.unmodifiableList(books);
}
```
> 누군가가 컬렉션을 수정하려고 하면 예외가 발생. 디버깅하는데 비용(특히 이미 사용되고 있는 코드의 경우 더욱)이 많이 든다.  
  
이런 방법 대신 컬렉션에 대한 제한적이지만 의미 있는 접근을 제공하는 메소드를 사용하자.  
```Java
void addBook(Book arrival) {
	books.add(arrival);
}
int bookCount() {
	return books.size();
}

Iterator getBooks() { // 사용자가 컬렉션 원소를 하나씩 접근해야 한다면 순차 열람자를 반환하는 메소드를 제공하자
	return books.iterator();
}
```
> 이렇게 되면 클라이언트에서 순차열람자에 remove() 메소드를 호출하지만 않는다면, 컬렉션이 수정되는 것을 막을 수 있다.  
  
클라이언트가 컬렉션 내용을 수정하는 것을 금지하고 싶다면, 컬렉션 원소를 제거할 경우 예외를 던지는 순차열람자를 반환하라
```Java
Iterator<Book> get Books() {
	final Iterator<Book> reader = books.iterator();
	return new Iterator<Book>() {

		public boolean hasNext() {
			return reader.hasNext();
		}

		public Book next() {
			return reader.next();
		}

		public void remove() {
			throw new UnsupportedOperationException();
		}

	}
}
```

## 불린 설정 메소드
불린 상태를 설정하는 가장 좋은 프로토콜은 뭘까? 가장 간단한 해법은 설정 메소드를 사용하는 것이다. 

```Java
void setValid(boolean newState) {
	...
}
```
> 클라이언트가 인자를 동적으로 바꾸는 유연성을 필요로 하는 경우라면 이 기법도 괜찮다.

```Java
void valid() {
	...
}

void invalid() {
	...
}
```
> 새로운 인터페이스를 사용하는 코드가 더 읽기 쉽고, 언제 어떤 상태로 변하는지 알기 쉽다.

```Java
...
if (...boolean expression...)
	cache.valid();
else 
	cache.invalid();
```
> 이런 코드가 나올 경우 setValid(newState)를 쓰자.




































