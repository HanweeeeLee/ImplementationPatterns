# 상태
 - 상태: 시간에 따라 변화하는 값을 사용하여 연산한다. 
 - 접근: 상태에 대한 접근을 제한해서 유연성을 조절한다. 
 - 직접 접근: 객체 내의 상태를 직접 접근한다.
 - 간접 접근: 좀더 나은 유연성을 위해 메서드를 통해 상태에 접근한다.
 - 공용 상태: 클래스의 모든 인스턴스에 적용되는 상태는 필드에 저장한다.
 - 가변 상태: 같은 클래스의 인스턴스마다 다른 상태를 유지해야 할 경우 상태를 맵에 저장한다.
 - 외재상태(Extrinsic State): 객체와 연동된 특수 상태는 상태의 사용자가 소유하는 맵에 저장한다.
 - 변수: 변수는 상태 접근에 필요한 네임스페이스를 제공한다.
 - 지역변수: 지역 변수는 단일 범위 내에서만 유효한 상태를 저장한다.
 - 필드: 필드는 객체가 생성될 떄부터 소멸될 때까지 상태를 저장한다.
 - 파라미터: 파라미터는 메서드가 활성화된 동안 상태를 전달한다.
 - 수집 파라미터: 여러 개의 메서드를 통해 복잡한 결과를 얻기 위해 파라미터를 전달한다.
 - 파라미터 객체: 자주 사용하는 긴 파라미터 목록은 객체로 만들어서 통합한다.
 - 상수: 변하지 않는 상태는 상수로 저장한다.
 - 역할 제시형 작명: 변수 이름은 연산에서의 역할을 반영하여 짓는다.
 - 선언형 타입: 변수에 대한 일반적인 타입을 선언한다.
 - 초기화: 변수 초기화는 가급적 선언적으로 한다.
 - 열성적 초기화: 인스턴스가 생성될 떄 필드를 초기화한다.
 - 게으른 초기화: 초기화 비용이 높은 객체의 경우, 객체가 실제 사용되기 직전에 초기화한다.

## 상태 
시간에 따라 변한다.  
상태는 개발자에게 문제를 가져오기도 한다. 잘못된 상태를 가정해서 개발할 수도 있고, 예상치 않게 상태가 변할 수도 있다. 또한, 병렬 프로그래밍과도 잘 맞지 않는다.  
객체 지향 언어는 상태를 다루는 데 적합한 전략이다. 접근 권한 기능을 이용해 '알지 못하는 사이에' 상태가 변하는걸 방지한다.  
효과적으로 상태를 관리하기 위해서 유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리하자.  
#### 1)두 개의 상태가 동일한 연산 안에서 사용하거나, 2) 동일한 시점에 생성되고 소멸되는지를 통해 묶을지를 판단하자.

## 접근
프로그래밍 언어는 두 가지 기능을 가지고 있다.  
1) 접근: 저장된 데이터에 접근해 데이터를 가져온다.  
2) 계산: 아직 저장되지 않은 메모리 값을 읽자.  
훌륭한 소프트웨어 개발은 당장 유효한 선택을 하되, 앞으로 있을 변화에 대해 유연성을 부여하는 것이다.  
저장(접근??)과 계산의 경계를 명확히 하자.  

## 직접 접근
데이터를 가져오거나 저장하는 것을 나타내는 가장 간단한 방법은 직접 변수 접을을 사용하는 것이다.  
```Java
x = 10;
```
> 너무나도 명확하지만 유연성이 떨어진다. 
#### 문제
 - 프로그램의 여러 부분에서 어떤 변수에 값을 저장한다면 프로그램을 수정할 떄 변수를 접근하는 모든 부분을 바꿔야한다.
 - 프로그래밍 할 때 프로그래머가 사고하는 수준보다 낮은 수준의 세부 구현을 사용한다. 예를들면 변수에 1을 저장하는것이 문을 여는것을 뜻한다던가..
```Java
doorRegist = 1;
-> 
openDoor();
->
door.open();
```
> 두번쨰 문제에 대한 예시
  
## 간접 접근
메소드 호출을 통해 상태 변화를 숨길 수도 있다. 접근자 메서드를 사용하면 명확성과 직접성을 희생해서 유연성을 얻을 수 있다.  
간접 접근이 유용한 경우로는 2개 이상의 데이터 간에 의존 관계가 존재하는 경우를 들 수 있다.  
```Java
Rectangle void setWidth(int width) {
	this.width = width;
	area = width * height;
}
```
하지만 리스너를 사용할 떄처럼 의존 관계가 명확하지 않은 경우도 있다.
```Java
Widget void setBorder(int width) {
	this.width = width;
	notifyListeners();
}
```
> 마땅히 답이 없을 때 쓰는 방법.

## 공용 상태
개발을 하다보면 여러 연산에서 같은 데이터 요소(값은 다를 수 있음)를 사용하는 경우가 많다. 이럴 경우는 클래스에 필드를 선언에서 사용하는 것이 좋다.  
```Java
class Point {
	int x;
	int y;
}
```
> Point를 표현하기 위해서는 x와 y를 가져야 한다는 사실을 명확히 알 수 있다.  
  
## 가변 상태
때로 같은 객체에서도 인스턴스에 따라 각각 다른 데이터 요소를 필요로 할 때도 있다. 단순 값만 다른게 아니라 전혀 새로운 데이터 요소들을 필요로 하는 경우.

```Java
class FlexibleObject {
	Map<String, Object> properties = new HashMap<String, Object>();
	Object getProperty(String key) {
		return properties.get(key);
	}
	void setProperty(String key, Object value) {
		properties.set(key, value);
	}
}
```
> 유연하긴한데........ 이건 똥이다. 직접 런타임에서 다 찍어봐야함 ㅡㅡ 다형성을 이용하던지, 제네릭을 이용하던지 합시다 ㅡㅡ by 정리한사람

가능하면 공용 상태를 사용하라. 경우데 따라 어떤 필드가 필요할지 확실치 않은 경우에만 가변 상태를 사용하라.

## 외재 상태
때로 프로그램의 일부에서만 객체의 특정 상태를 필요로 하는 경우가 있다.  
어떤 객체와 관련된 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장하자.  
외재 상태를 사용하면 객체의 복사가 어려워진다.  
 - 모든 외재 상태를 올바르게 복사하려면 상태를 어떻게 사용하는지 알아야 한다. 
 - 일반적인 디버거는 객체의 외재 상태를 보여주지 않는다(ㄹㅇ?)

하지만 적절히 사용하면 좋음

## 변수
 - 코드를 읽는 사람은 변수의 범위, 생명기간, 역할, 런타임 타입 등에 대한 정보를 알아야 한다. 가급적이면 단순한 이름을 통해 코드를 단순화 하자.
 - 모든 종류의 변수를 사용할 수 있는 경우, 이름을 통해 변수 종류를 나타내는것이 중요하다. 하지만 지역변수를 주로 사용해서 의존성을 줄이고 이름을 통해 귀찮게 나타내지 말자. 
 - 변수의 생명 기간은 변수의 범위보다 작을 수 있다. 되도록이면 변수의 생명 기간과 범위를 맞춰주자.
 - 변수의 타입은 타입 선언에 따라 독자에게 전달된다. 타입을 가급적 명확하게 하자. 

## 지역 변수 
지역 변수는 변수가 선언된 지점이 속한 범위에서만 접근할 수 있다. 지역 변수는 사용되기 직전에 가급적 최소 범위 내에서 선언하자.  
지역 변수는 다음과 같은 역할을 한다.
 - 컬렉터: 이후 사용을 위한 정보를 모은다. 떄로 컬렉터의 값은 함수를 통해 반환되기도 한다. 
 - 카운터: 특정 객체의 수를 저장하는 특수 컬렉터
 - 설명: 복잡한 표현을 해야하는 경우 좀 쉽게 볼 수 있게 도와준다.
```Java
// 설명의 예시
int top = ...;
int left = ...;
int height = ...;
int width = ...;
return new Rectangle(top, left, height, width)
```
 - 재사용: 값이 바뀌지만 기존 값을 다시 사용해야하는경우 저장해서 씀
```Java
// 재사용 예시
long new = System.currentTimeMillis();
for (Colock each: getClocks())
    each.setTime(now);
```
 - 원소: 지역 변수는 현재 사용하는 컬렉션의 원소를 저장하기 위해 사용될 떄도 있다
```Java
 // 원소에 대한 설명
 broadcast() {
    for (source eachSender: getSenders())
        for (Destination eachReceiver: getReceivers())
            ...;
 }
```

## 필드
필드의 범위와 생명기간은 필드를 갖고 있는 객체와 같다. 필드는 객체 전반에 걸쳐 사용되므로 모든 필드는 모아서 선언하자.  
필드 변수의 역할에 대해 알아보자. 필드 변수는 지역 변수에 비해 용도가 많지 않다.

 - 도우미: 도우미 필드는 객체의 여러 메서드에서 사용하는 객체를 저장한다.
 - 플래그: 말 그대로 플래그. 플래그에 따라 결정을 내리는 코드가 중복되어 있다면, 대신 전략 필드를 사용하는것을 고려하자.
 - 전략: 객체의 연산을 하는 다른 방법이 있음을 나타내는 경우, 그 부분을 수행하는 객체를 필드에 저장하라. 객체의 생명기간 동안 연산 방법이 바뀌지 않는 경우라면, 생성자에서 전략 필드를 설정하라. 그렇지 않다면 전략 필드를 수정하는 메서드를 제공하라. 
 - 상태: 객체의 행위 양식을 결정한다는 점에서 상태 필드는 전략 필드와 비슷하지만 상태 필드는 스스로 다음 상태를 설정한다. 반면 전략 필드는 다른 객체에 의해 설정된다.
 - 부속: 부속 필드는 해당 객체가 소유하는 객체나 데이터를 저장한다. 


## 파라미터 
비전용 변수(필드 혹은 정적 필드)를 사용하지 않고 상태를 다른 객체에 전달하려면 파라미터를 사용한다. 비전용 변수를 사용하면 클래스 간에 강한 의존성이 생김. 그렇기때문에 정적 변수와 파라미터를 모두 사용할 수 있는 경우라면 파라미터를 사용하자.  
파라미터로 생기는 의존성은 영구적인 참조를 통해 발생하는 의존성보다 약하다.  
![KakaoTalk_Photo_2022-08-21-23-57-19](https://user-images.githubusercontent.com/60125719/185797268-dd0be86e-0317-4d5e-86db-11c0c30ccc66.jpeg)
![KakaoTalk_Photo_2022-08-22-00-00-36 001](https://user-images.githubusercontent.com/60125719/185797374-8dd8b432-bb6c-4da6-bcdc-16b12b6a707c.jpeg)
하나의 객체에서 다른 객체에 대한 여러 메시지가 같은 파라미터를 필요로 한다면, 그 파라미터를 호출되는 객체에 포함시키는 것이 나을 수도 있다.  

### example
```Java
Server s = new Server();
s.a(this);
```

같은 파라미터를 5번 반복하면 의존성이 크게 강화된다.
```Java
Server s = new Server();
s.a(this);
s.b(this);
s.c(this);
s.d(this);
s.e(this);
```
![KakaoTalk_Photo_2022-08-22-00-00-37 002](https://user-images.githubusercontent.com/60125719/185797416-94b2e7af-4f35-4479-80a4-17ecea249808.jpeg)

이런 경우, 파라미터를 객체 내로 옮기면 다음과 같이 2개의 객체에 독립성이 부여된다.
```Java
Server s = new Server(this);
s.a();
s.b();
s.c();
s.d();
s.e();
```
![KakaoTalk_Photo_2022-08-22-00-03-08](https://user-images.githubusercontent.com/60125719/185797478-04743934-ae35-455b-8dfb-febb09b93fac.jpeg)
























