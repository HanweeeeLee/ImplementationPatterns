# 05. 클래스
플라톤은 현실세계에 존재하는 것은 클래스의 인스턴스일 뿐이라고 얘기했는데, 객체지향 프로그래밍은 이 아이디어를 받아들여서  
프로그램을 클래스와 객체로 구성한 것이다.  
클래스는 잠재적으로 여러 세부 사항을 내포할 수 있으므로, 클래스의 사용은 커뮤니케이션을 위한 프로그램에 있어 매우 중요하다.

## 클래스 : "이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다."라는 이야기를 하고 싶을 때 클래스를 사용한다.
클래스를 사용하는 기본 이유는 데이터가 로직에 비해 빈번하게 변화가기 떄문이다.  
하지만 데이터의 변화율이 로직에 비해 높다는 말은 절대적이지 않다.  
때로 로직은 데이터에 의존적으로 변하기도 하고, 더 큰 단위에서 변화하기도 한다. 또한 연산 과정에서 데이터가 변하지 않는 경우도 있다.  
객체를 사용해서 효과적인 프로그래밍을 하기 위해서는 로직을 클래스 단위로 어떻게 구성해야 하는지, 로직 사이의 차이점을 어떻게 효과적으로 표현해야 하는지  
배워야 한다.  
클래스는 객체 지향 프로그램의 설계요소 중 비교적 값이 비싼 편이므로, 뭔가 의미있는 작업에만 클래스를 사용해야 한다.  
다른 클래스의 크기를 너무 비대하게 하지 않으면서 클래스의 수를 줄이는 것은 프로그램을 개선한 것이라 할 수 있다.

## 단순한 상위 클래스 이름 : 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다. 
클래스 이름을 지을 때는 간결성과 표현성 사이에서 고민하게 된다.  
클래스 이름은 가급적 짧으면서 핵심을 찔러야 하지만, 좀더 정확한 의미를 전달하기 위해 몇 개의 단어를 사용해야 하는 경우도 있다.  
이런 딜레마에서 벗어나는 방법으로 메타포(은유)를 사용하는것이 좋다.

## 한정적 하위 클래스 이름 : 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다. 
하위클래스 이름은 상위클래스와의 유사점과 차이점을 나타내야 한다.  
이 경우에도 결국 간결성과 풍부한 표현성 사이에서의 고민인데, 클래스 계층 최상위에 있는 클래스와 달리 하위 클래스는  
어느 정도 간결성은 포기하더라도, 표현성을 택하는 편이 낫다.  
보통은 상위 클래스 이름에 한두개의 수식어를 붙여서 하위클래스 이름을 정하는 경우가 많다.  
하지만 하위클래스가 상위 클래스의 메커니즘을 빌려서 사용할 뿐, 그 자체로 프로그램의 중요한 개념을 의미하는 경우라면  
단순한 이름을 사용하여, 다른 하위 클래스 이름과는 차별되는 단순한 상위 클래스 이름을 부여받을 자격이 있게 된다.

## 추상 인터페이스 : 인터페이스와 구현을 분리한다.
대부분 코드가 컬랙션 인터페이스를 사용한다면, 구상 클래스를 나중에 얼마든지 바꿀 수 있다. 구상 클래스는 컴퓨터가 실제 연산을 하기 전에만 결정되면 된다.
인터페이스 란 구현이 빠진 여러 연산의 집합을 의미한다.  
인터페이스 추가에는 비용이 발생하는데, 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다.  
소프트웨어는 유연해야 하지만, 유연성에는 비용이 들고, 어떤 부분에서 유연성이 필요할지 예측하기란 쉽지 않다.  
따라서 실제 필요해지는 경우에만 시스템에 유연성을 부여하자는 결론에 이르게 된다.

## 인터페이스 : 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다." 라고 이야기 하는것과 같다.
인터페이스는 필드를 배제하고 연산만을 나타내므로 사용자는 구현이 변경되더라도 신경 쓸 필요가 없다.  
인터페이스를 사용하면 구현을 바꾸는 것은 쉽지만, 인터페이스 자체를 바꾸기는 쉽지 않다.  
인터페이스를 조금이라도 바꾸거나 추가하면, 그 인터페이스를 구현하는 모든 클래스를 수정해야 하기 떄문이다.

## 추상클래스 : 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
추상클래스는 기본 구현을 사용할 수 있는 길이 열려있는 한, 기존 설계를 망가뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다.  
추상클래스의 단점은 각 클래스가 단 1개의 상위클래스 만을 지정할 수 있다는 것이다.  
자바 클래스에서 abstract 키워드를 씀으로써, 해당 클래스를 사용하기 위해서는 반드시 구현이 필요하다는 사실을 코드 독자에게 전달할 수 있다.  
클래스 계층에서 최상위에 위치한 클래스를 인스턴스화해서 사용할 가능성이 조금이라도 있다면 그렇게 하라.  
추상화를 진행하다 보면, 쓸데없는 추상 클래스를 너무 많이 만들게 되는 경우가 생긴다.  
최상위 클래스를 인스턴스화 가능한 클래스로 만들면 이런 쓸데 없는 추상 클래스 계층을 제거할 수 있다.

## 버전 인터페이스 : 하위인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다. 
인터페이스를 변경하고 싶을 때, 새로운 인터페이스를 선언하여 기존 인터페이스를 확장(상속)한 후 새로운 연산을 추가 할 수 있다.  
새로운 연산을 사용하는 경우, 반드시 객체의 타입을 확인 후 새로운 타입으로 다운 캐스트 해서 사용해야 한다.  
간단한 Command 인터페이스를 살펴보자
```JAVA
interface Command {
	void run();
}
```
이 인터페이스가 공개되고 널리 사용된 상황에서 인터페이슬 바꿀경우 수정비용이 엄청날 것이다.  
하지만 다음과 같이버전 인터페이스를 사용해서 그 인터페이스에 undo() 메소드를 추가하면 문제를 해결할 수 있다.
```JAVA
interface ReversibleCommand extends Command {
	void undo();
}
```
이 경우 기존 Command 인터페이스를 사용한 코드는 여전히 잘 동작한다.  
새로 선언한 ReversibleCommand 역시 기존 Command가 동작하는 모든 경우에 잘 동작한다.  
새로운 기능을 사용하고 싶을 때는 다음과 같이 다운캐스트 해서 사용한다.
```JAVA
Command recent = ...;
if (recent instanceof ReversibleCommand) {
	ReversibleCommand downCasted = (ReversibleCommand) recent;
    downCasted.undo();
}
```
대체 인터페이스는 달갑지 않은 문제에 대한 달갑지 않은 해결책이다.  
인터페이스를 사용하면 구현을 쉽게 바꿀 수 있지만, 인터페이스 자체는 바꾸기 매우 어렵다.  
대체 인터페이스를 사용하는 것은 자바를 올바르게 사용하는 것이라고 볼수 없지만, 인터페이스를 확장할 수 밖에 없는 경우에 대비해  
사용법을 알아 두는 편이 좋다.

## 값 객체 : 산술 값처럼 동작하는 객체를 사용한다. 
```JAVA
class Transaction {
    int value;
    Transaction(int value, Account credit, Account debit) {
        this.value = value;
        credit.addCredit(this);
        debit.addDebit(this);
    }
}
```
위의 Transaction 객체의 경우, 일단 생성된 후에는 값을 변경하는 것이 불가능하다.  
더구나 객체 생성 시 생성자는 2개의 Account 객체를 모두 업데이트 해준다.  
따라서 이 코드를 보면 거래가 중간에 중단되는 경우나 거래 금액이 나중에 바뀌는 경우를 미리 걱정할 필요가 없다는 것을 알 수 있다.  
이렇게 값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)를 구현하려면, 먼저 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야 한다.  
위의 예에서 Transaction은 값 스타일 객체이고, Account는 변화하는 상태를 가진 객체다.  
값 스타일 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다.  
값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다. 이러한 객체는 연산을 요청한 쪽에서 저장한다.

## 특화 : 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다. 
연산 간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다.  
코드에서 유사점과 차이점을 부각시키면 코드 독자가 명확히 코드를 이해하고, 기존 코드가 새로운 요구사항을 처리할 수 있을지 판단할 수 있다.  
또 수정이 필요한 경우 기존 코드를 변형해서 특화하는 것이 좋을지 완전히 새로운 코드를 짜는것이 좋을지 판단할 수 있다.

## 하위클래스 : 1차원적 변화는 하위 클래스를 사용해서 표현한다. 
하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..." 이라 말하는것과 같다.  
제대로 된 상위 클래스를 갖고 있다면 하위클래스는 강력한 힘을 발휘할 수 있다.  
적당한 메소드를 오버라이드할 경우 간단한 코드 몇줄이면 기존 연산과 다른 변형을 만들어 낼 수 있기 때문이다.
하위 클래스 사용시 몇가지의 문제점이 있는데  

1. 일단 하위클래스를 사용하면 되돌리기가 쉽지 않다.
2. 하위 클래스를 이해하기 위해서는 일단 상위 클래스를 이해해야 한다.
3. 하위클래스가 상위 클래스 세부 구현 특성에 의존할수 있으므로 상위클래스의 수정이 위험해 진다.

하지만 이러한 문제점을 충분히 인지 하고 있는다면, 하위 클래스는 연산의 다양한 변형을 나타낼 수 있는 강력한 도구다.  
알맞은 곳에 하위 클래스를 사용하면, 한두개의 메소드만으로도 원하는 연산을 정확히 표현할 수 있다.  
하위 클래스 사용을 제한하는 마지막 요소는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다.  
하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야 하며 이는 이후에 바뀔 수 없다.  
변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하라.

## 구현자 Implememtor : 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.  
Implements를 사용해서 자바 인터페이스를 사용하건 extends를 사용해서 하위클래스를 사용하건 간에, 같은 프로토콜을 여러 번 구현하는 것은  
"코드의 목적에 부합하게 구현된 경우, 이 연산의 내부 구현에 대해서는 신경 쓰지 않아도 괜찮다"는 것을 의미한다.

## 내부 클래스 : 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다. 
떄로 어떤 연산을 표현하기 위한 클래스가 필요하지만, 새로운 파일에 완전히 새로운 클래스를 만들고 싶지는 않을 때,  
작은 전용 클래스(내부 클래스)를 사용하면 클래스 사용에 따른 비용을 지불하지 않으면서도 클래스의 장점을 대부분 취할 수 있다.

## 인스턴스별 행동 instance-specific behavior : 인스턴스에 따라 로직에 변화를 준다.  
이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다. 하지만 이런 제약사항을 완화하면 새로운 스타일의 표현이 가능하다.  
물론 새로운 스타일을 사용하려면 비용이 들고, 연산 수행 도중에 로직이 변화하는 경우 비용은 더욱 커지게 된다.  
코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 편이 좋다.

## 조건문 : 명시적 조건에 따라 로직에 변화를 준다.
조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이 하나의 클래스 안에 들어있다는 것이다.  
그러나 조건문을 사용하면 인스턴스 행동을 변경하기 위해 해당 클래스 코드를 고쳐야 한다.  
수행경로가 다양한 프로그램이 그렇지 않은 프로그램에 비해 결함을 갖고 있을 확률이 높은 것은 사실이고, 따라서 조건문의 수가 많으면 많을수록  
프로그램의 안정성이 떨어지는 경향이 있다.  
요컨데 조건문은 단순성과 지역성(하나의 클래스만 수정)에서 장점이 있지만, 광범위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.

## 위임 delegation : 여러 종류의 객체 중 하나에 위임해서 로직에 변화를 준다. 
각 인스턴스에서 다른 로직을 수행하도록 하는 다른 방법으로는 위임(몇가지 객체 중 하나를 선택해서 작업을 미루는 것)이 있다.  
공통으로 사용되는 로직은 위임 클래스를 참조하는 클래스에 들어 있지만, 변형은 여러 객체에 각각 구현된다.  

## 플러그인 선택자 pluggable selector : 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다. 
한두개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스안에 들어가도 좋은 경우,  
메소드 이름을 필드에 저장해 두고 리플렉션을 통해 메소드를 호출하는 것도 좋다.  
플러그인 선택자 사용에 따르는 비용은 상당하므로, 그 비용을 정당화 할수 있는 일부 어려운 문제에만 제한적으로 사용해야 한다.

## 익명 내부 클래스 : 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다. 
익명 내부 클래스는 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드 한 후, 지역적으로만 사용하는 것이다.  
특정 지역에서만 사용되므로 이러한 클래스는 이름이 필요 없다.  
익명 내부 클래스코드는 내부 클래스를 사용하를 사용하는 클래스의 코드를 읽는데 방해가 되므로 가급적 짧아야한다.

## 라이브러리 클래스 : 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.
라이브러리 클래스는 인스턴스화가 불가능한, 라이브러리 메소드만을 갖고 있는 클래스다.  
라이브러리 클래스는 널리 사용되고 있는 기법이지만 메소드 수가 많아질 경우 문제가 드러난다.  
모든 로직을 정적 메소드로 구현하면, 객체 지향 프로그래밍의 가장 큰 장점(공유데이터를 전용 네임 스페이스를 사용하여 표현해서 로직을 단순화 하는것)  
을 잃게 된다. 그러므로 가능한 경우 라이브러리 클래스는 객체로 변환하는 것이 좋다.  
라이브러리 클래스를 점진적으로 객체로 바꾸기 위해서는 정적 메소드를 인스턴스 메소드로 바꾸면 된다.  
처음에는 정적 메소드가 인스턴스 메소드에 위임하는 방식을 사용해서 같은 인터페이스를 유지하는 것이 좋다.
