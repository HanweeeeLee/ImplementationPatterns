# 10. 발전하는 프레임워크

코드를 이해하고 커뮤니케이션하는 데 드는 비용에 비해 코드 수정에 드는 비용이 대부분 훨씬 저렴하지만, 프레임워크 개발의 경우 프레임워크 개발자가 클라이언트 코드를 수정할 수 없으므로 이 가정이 성립하지 않는다.  
호완성을 깨뜨리는 업데이트에 대한 비용은 너무 비싸므로 그런 업데이트는 최대한 피해야 한다.  

## 애플리케이션 수정 없이 프레임워크 수정하기
이상적인 프레임워크 업그레이드는 기능 추가를 하면서도 기존 기능이 변함 없이 작동하게 해야 한다. 하지만 이것이 항상 가능한것은 아님.  
프레임워크 개발의 경제성을 향상시키기 위해서는 호완성이 유지되지 않는 업그레이드가 발생할 확률을 낮추고, 어쩔 수 없는 경우 비용을 최소화 해야 한다.  
  
프레임워크 개발에 있어서는 호환성이 중요하지만, 단순성도 여전히 중요하다. 균형을 맞추자.  
프레임워크를 개발할 떄는 복잡도를 낮출 만한 발전의 여지를 남겨 두면서도 충분히 단순해서 당장 사용할 수 있어야한다. 또한 적용 범위를 확대할 여지를 남겨두면서도 당장 사용할 수 있을 정도의 적용성을 가져야 한다. 이래서 프레임워크 개발은 애플리케이션 개발에 비해 위험성이 높고 비용이 많이든다.  

## 호환성 없는 업그레이드
호환성이 없이 없그레이드 할 때 업그레이드를 여러 단계로 나누면 클라이언트에게 앞으로 어떤 변화가 생길지 미리 알려주게 되어 언제 코드를 고쳐야하는지 결정할 수 있게 해준다.
예를 들면 deprecation을 표시해주고 한두 번의 릴리즈에서 해당 기능을 계속 제공한다던지..  
병렬 아키텍처는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.  
  
패키지를 사용하면 점진적으로 클라이언트 코드를 업그레이드 할 수 있다.  
코드를 그대로 사용하고 import를 바꿔주자. 이건 위의 경우보다 안전할 수 있음  
  
다른 점진적 업그레이드 전략은 API와 구현을 바꾸되 한번에 둘 모두를 바꾸지 않는 것이다.  
인터페이스를 바꾸거나 구ㅕㄴ을 바꾼 중간 릴리즈 코드는 프레임워크를 제공하는 측과 클라이언트에게 모두 변화의 방향에 익숙해질 시간을 제공한다. 시간을 확보 할 수 있음.  
  
이 외에 다른 고려해야 할 상황은 퇴보한 기능을 언제까지 지원해줄 것이냐임  
이에 대해선 얼마나 자주 업데이트 하느냐가 기준이 될 수 있다. 균형을 맞추자 ㅡㅡㅋ  
  
성장하는 프레임워크는 이런 업데이트가 발생하더라도 클라이언트는 비용을 감수하고서라도 수정을 할 것이다.  
그게 아니라면.. 수정을 포기할 지도 모른다.  
잘못된 업데이트는 대부분의 고객을 잃어버리게 할 수 있다... 

## 호환성을 유지하는 업그레이드
호환성을 유지하면서 프레임워크를 업그레이드 하기 위해 클라이언트 코드는 가급적 프레임워크의 세부 구현에 의존하지 않아야 한다.  
이상적인 경우 클라이언트는 프레임워크의 변하지 않는 부분(invariants)에만 의존적이어야 한다.  
그러나 프레임워크의 확장과 변화는 예상할 수 없으므로 어떤 부분이 변화하지 않을지 미리 알 수 있는 방법은 없다.  
하지만 가급적 눈에 보이는 세부사항을 숨기고 변화하지 않을 가능성이 높은 부분만을 노출시킨다면 나중에 유리할것.  
  
한 가지 결정해야 할 사항은 어떤 종류의 호환성을 제공하는가 하는 것.  
하위 호환성(backward compatibility)업그레이드를 통해 프레임워크에 구형 메소드 호출과 구형 객체 전달을 지원할 것인가? 아니면 상위 호환성(forward compatibility)업그레이드를 통해 신형 스타일의 객체를 클라이언트에 전달해 동작하도록 할 것인가?  

## 라이브러리 클래스
(정적 메소드들의 집합, Util성 클래스인듯???)  
라이브러리 클래스를 사용하면 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.  
새로운 버전의 라이브러리 클래스를 릴리즈 하는 경우에도 기존 메소드가 이전과 같이 동작하는지만 확인하면 된다.  
ex) Collections 클래스: 새로운 버전의 라이브러리 클래스에서는 기존 기능을 그대로 나둔 채 새로운 정적 메소드를 추가한다.  

## 객체
프레임워크를 객체로 나타내는 경우, 단순성과 복잡성 사이, 유연성과 구체성 사이에서 균형을 잡기는 더욱 어려워진다.  
프레임워크는 클라이언트에게 유용하고 안정적이면서 프레임워크 개발자에게는 발전시키기 쉬워야 한다.  
클라이언트가 프레임워크의 바뀌지 않을 것 같은 부분에만 의존적으로 코드를작성하자.  
  
프레임워크를 객체로 나타낼 때에는 네 가지 이슈가 있다.
 - 사용 스타일: 클라이언트가 프레임워크 객체를 인스턴스화해서 사용할 것인가 아니면 확장시켜서(상속) 사용할 것인가?
 - 추상화: 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가? 상대적으로 안정적인 세부 사항에 대해 어떤 가시성을 사용할 것인가?
 - 생성: 어떻게 객체를 생성하는가?
 - 메소드: 메소드를 어떻게 구성하면 클라이언트에게는 유용성을, 프레임워크 개발자에게는 유연성을 제공할 수 있을까?

### 사용 스타일
프레임워크는 인스턴스화, 설정, 구현의 세 가지 주요 스타일을 지원한다.  
가장 단순한 스타일은 인스턴스화이다. 서버 소켓을 사용하고 싶다면 new ServerSocket()을 사용하면 된다. 클라이언트가 로직의 변형을 필요로 하지 않고 데이터의 변형만을 필요로 하는 경우 인스턴스화를 사용하라.  

설정은 인스턴스화보다 복잡하지만 좀더 유연하다. 예를들면.. 
```java
// TreeSet은 클라이언트에서 정의하는 Comparator를 사용해서 원소 사이의 정렬을 수행한다.
Comparator<Author> byFirstName = new Comparator<Author>() {
	public int compare(Author book1, Author book2) {
		return book1.getFirstName().compareTo(book2.getFirstName());
	}
};
SortedSet<Author> sorted = new TreeSet<Author>(byFirstName);
```
설정은 데이터뿐 아니라 로직의 변형도 지원하므로 인스턴스화보다 유연하다. 그러나 설정을 사용해서 클라이언트 객체를 호출하는 경우, 계속해서 같은 인터페이스를 사용해야 하므로 프레임워크를 발전시키는 데 제한이 생기고 클라이언트 코드에 대한 호환성을 보장해주기 어려워진다.  
또한 실질적으로 표현할 수 있는 변형의 종류에도 제한이 있다. 예를 들어 어떤 객체 설정에 2개 이상의 옵션이 들어가는 경우 클라이언트가 쉽게 사용할 수 없을것.  
  
클라이언트가 설정에서 제공하는 것 이상으로 많은 종류의 로직의 변형을 필요로 하는 경우, 구현에 의한 상요을 제공할 수 있다. 이 경우 클라이언트는 프레임워크에서 사용할 클래스르를 생성해서 프레임워크에 전달한다.  
클라이언트 클래스가 프레임워크의 클래스나 인터페이스를 확장하거나 구현하는 한 클라이언트는 어떤 로직이라도 사용할 수 있다.    
  
객체를 사용하는 세 가지 스타일 중에서 구현은 미래에 있을 설계 변경을 가장 크게 제한한다. 호환성을 보장하기 위해서는 프레임워크에서 제공하는 상위클래스나 인터페이스를 그대로 유지해야 하기 때문이다.  
프레임워크 추상화에서 세부 사항을 노출하는것은 양날의 검. 이를 통해 클라이언트는 자신의 코드를 사용할 수 있게 되지만, 프레임워크 개발자는 기존 클라이언트 코드와의 호환성을 포기하지 않는 이상 앞으로도 같은 인터페이스를 계속 사용해야 하기 떄문이다.  
  
구현 스타일은 설정에 비해 표현할 수 있는 범위가 훨씬 넓다. 필요한 경우 프레임워크에서 제공하는 메소드에 원하는 변형만을 구현하면 되기 때문이다.  

### 추상화

추상화된 기념을 인터페이스로 전달해야 하는지, 상위클래스로 전달해야 하는지 결정해야 한다.

#### 인터페이스

인터페이스를 클라이언트에게 제공할 때의 이점은 세부 사항을 가급적 적게 드러낸다는 것이다. 인터페이스를 사용할 경우 클라이언트가 '실수로' 의도한 것보다 많은 기능을 사용하게 될 일은 없다.  
주의할 점은 새로운 메소드를 인터페이스에 추가하는 경우 기존 인터페이스에 대한 모든 클라이언트 구현이 동작하지 않게 된다. 클라이언트가 인터페이스를 사용하지만 구현하지 않는 경우에만 새로운 메소드를 추가해도 괜찮다.(자바 전용??????? 뭐지..)  
  
약간의 비용을 추가해서 인터페이스에 유연성을 부여한 형태로는 버전 인터페이스가 있다. 인터페이스 연산을 추가할 경우, 클라이언트 코드는 더이상 동작하지 않는다. 그러나 하위 인터페이스를 만들어서 새로운 연산을 추가할 경우, 기존 인터페이스가 필요한 경우에도 새로운 인터페이스를 사용할 수 있고, 기존 인터페이스에 따라 작성한 코드도 계속해서 사용가능하다. -> 하지만 복잡성이 증가함. 명시적으로 타입을 변경해줘야한다.  
```Java
...
if (layout instanceof LayoutManager2) {
	LayoutManager2 layout2 = (LayoutManager2) layout;
	layout2.newOperation();
}
...
```
추가적으로 다중상속 가능

#### 상위클래스
인터페이스를 사용하는 대신 클라이언트가 프레임워크에 특정 클래스나 특정 클래스의 하위클래스의 인스턴스를 전달하게 할 수도 있다. 이러한 스타일의 장단점은 인터페이스 스타일의 장단점의 반대이다.  
메소드가 추가되도 호환성에 문제가 되지 않지만 단 하나의 프레임워크 클래스만을 상속할 수 있다.  
이것을 사용하기로 했으면 가급적 클래스에서 노출하는 세부 사항을 줄여서 인터페이스에서 노출하는 정보 수준에 가깝게 하라.  
  
abstract 키워드를 사용하면 클라이언트에게 어떤 로직을 제공해야 하는지 알려줄 수 있다.  
  
final 키워드를 클래스에 사용하면 하위클래스를 생성할 수 없게 되어 인스턴스화나 설정 스타일 중 한 가지 방법으로 프레임워크를 사용해야만 한다.  
메소드에 final 키워드를 사용하면, 클라이언트에 노출된 메소드에 대해 언제나 어떤 메소드가 수행될지 보장해준다.  
  
### 생성
프레임워크에서 어떤 구상 클래스를 사용하는 경우, 클라이언트는 어떻게 클래스를 인스턴스화할지 결정해야한다. 다른 프레임워크 결정 사항들과 마찬가지로 인스턴스화 방법을 정할 떄는 일반성, 복잡도, 사용의 용이성, 발전용이성 등을 모두 고려해서 균형 잡힌 결정을 해야 한다.

#### 생성 금지
가장 단순하고 유용성이 떨어지는 옵션은 클라이언트가 프레임워크 객체를 직접 생성하는 것을 금지하는 것이다.  
이벤트를 언제나 프레임워크 내부에서 생성하면 프레임워크 개발자는 이벤트가 언제가 올바른 형식을 갖추고 있는 것을 보장할 수 있다. 이렇게 이벤트에 대한 가정을 두고 프레임워크 코드를 작성할 경우 복잡도를 낮출 수 있다.  
하지만 클라이언트가 객체 생성을 금지 당하면, 프레임워크 개발자가 생각하지 못한 클래스를 사용할 수 없는 단점이 있다. 이것은 프레임워크 개발자가 생각하지 못한 유용한 방법을 금지하는 길일지도 모른다...

#### 생성자
클라이언트가 생성자를 통해 객체를 생성하게 하는 것은 간단하지만, 이는 이후 프레임워크 수정에 상당한 제약을 가져온다.  
생성자를 공개하는 것은 클래스 이름, 객체 생성에 필요한 파라미터, 클래스가 속한 패키지 등 반환되는 구상 클래스의 대부분의 요소를 수정하지 않겠다고 선언하는 것과 같다.  
생성자를 통해 객체를 생성하는 것의 장점은 클라이언트 입장에서 볼 때 단순 명확하다는 것이다.

#### 정적 공장(static factories)
저적 공장을 사용하면 클라이언트가 객체를 생성하는 복잡도가 상당히 증가하지만, 프레임워크 개발자는 미래의 설계 수정에 유연성을 갖게 된다.  
클라이언트가 생성자 대신 ArrayList.create()를 사용해서 리스트를 생성했다면, 클라이어트 코드를 바꾸지 않고도 반환되는 객체의 이름, 패키지, 구상 클래스는 변경할 수 있다.  
하지만 생성 과정을 추상화할수록 코드를 읽으면서 어느 곳에서 객체가 생성되는지를 알기는 어려워진다.  
공장 메소드의 다른 장점은 객체 생성 시의 변형을 클라이언트에게 좀더 명확히 전달할 수 있다는 것이다.  

#### 공장(팩토리) 객체
정적 메소드를 호출하는 대신 공장 객체에 메시지를 보내서 인스턴스를 생성하는 방법도 있다.  
예를들어 CollectionFactory 클래스에서 여러 종류의 컬렉션을 생성하는 메소드를 제공하고, Collections.factory().createArrayList()와 같은 메소드 호출을 통해 리스트를 생성한다던지..  
공장 객체를 사용하면 정적 메소드보다 높은 유연성을 얻을 수 있지만, 코드를 읽기 어려워진다. 어떤 클래스가 생성되는지 알기 위해서는 코드 수행을 따라가야 하기 때문  
공장 객체를 global로 사용한다면 공장 객체는 정적 공장 메소드보다 나을게 없다.  

#### 맺음말
프레임워크에서 객체 생성을 어떻게 하느냐는 프레임워크의 사용과 수정의 용이성에 영향을 준다. 한 가지 전략은 변화할 것 같은 객체에는 공장 메소드를 사용하고 안정적인 클래스에는 생성자를 사용하는 것이다.
 


































