# 10. 발전하는 프레임워크

코드를 이해하고 커뮤니케이션하는 데 드는 비용에 비해 코드 수정에 드는 비용이 대부분 훨씬 저렴하지만, 프레임워크 개발의 경우 프레임워크 개발자가 클라이언트 코드를 수정할 수 없으므로 이 가정이 성립하지 않는다.  
호완성을 깨뜨리는 업데이트에 대한 비용은 너무 비싸므로 그런 업데이트는 최대한 피해야 한다.  

## 애플리케이션 수정 없이 프레임워크 수정하기
이상적인 프레임워크 업그레이드는 기능 추가를 하면서도 기존 기능이 변함 없이 작동하게 해야 한다. 하지만 이것이 항상 가능한것은 아님.  
프레임워크 개발의 경제성을 향상시키기 위해서는 호완성이 유지되지 않는 업그레이드가 발생할 확률을 낮추고, 어쩔 수 없는 경우 비용을 최소화 해야 한다.  
  
프레임워크 개발에 있어서는 호환성이 중요하지만, 단순성도 여전히 중요하다. 균형을 맞추자.  
프레임워크를 개발할 떄는 복잡도를 낮출 만한 발전의 여지를 남겨 두면서도 충분히 단순해서 당장 사용할 수 있어야한다. 또한 적용 범위를 확대할 여지를 남겨두면서도 당장 사용할 수 있을 정도의 적용성을 가져야 한다. 이래서 프레임워크 개발은 애플리케이션 개발에 비해 위험성이 높고 비용이 많이든다.  

## 호환성 없는 업그레이드
호환성이 없이 없그레이드 할 때 업그레이드를 여러 단계로 나누면 클라이언트에게 앞으로 어떤 변화가 생길지 미리 알려주게 되어 언제 코드를 고쳐야하는지 결정할 수 있게 해준다.
예를 들면 deprecation을 표시해주고 한두 번의 릴리즈에서 해당 기능을 계속 제공한다던지..  
병렬 아키텍처는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.  
  
패키지를 사용하면 점진적으로 클라이언트 코드를 업그레이드 할 수 있다.  
코드를 그대로 사용하고 import를 바꿔주자. 이건 위의 경우보다 안전할 수 있음  
  
다른 점진적 업그레이드 전략은 API와 구현을 바꾸되 한번에 둘 모두를 바꾸지 않는 것이다.  
인터페이스를 바꾸거나 구ㅕㄴ을 바꾼 중간 릴리즈 코드는 프레임워크를 제공하는 측과 클라이언트에게 모두 변화의 방향에 익숙해질 시간을 제공한다. 시간을 확보 할 수 있음.  
  
이 외에 다른 고려해야 할 상황은 퇴보한 기능을 언제까지 지원해줄 것이냐임  
이에 대해선 얼마나 자주 업데이트 하느냐가 기준이 될 수 있다. 균형을 맞추자 ㅡㅡㅋ  
  
성장하는 프레임워크는 이런 업데이트가 발생하더라도 클라이언트는 비용을 감수하고서라도 수정을 할 것이다.  
그게 아니라면.. 수정을 포기할 지도 모른다.  
잘못된 업데이트는 대부분의 고객을 잃어버리게 할 수 있다... 

## 호환성을 유지하는 업그레이드
호환성을 유지하면서 프레임워크를 업그레이드 하기 위해 클라이언트 코드는 가급적 프레임워크의 세부 구현에 의존하지 않아야 한다.  
이상적인 경우 클라이언트는 프레임워크의 변하지 않는 부분(invariants)에만 의존적이어야 한다.  
그러나 프레임워크의 확장과 변화는 예상할 수 없으므로 어떤 부분이 변화하지 않을지 미리 알 수 있는 방법은 없다.  
하지만 가급적 눈에 보이는 세부사항을 숨기고 변화하지 않을 가능성이 높은 부분만을 노출시킨다면 나중에 유리할것.  
  
한 가지 결정해야 할 사항은 어떤 종류의 호환성을 제공하는가 하는 것.  
하위 호환성(backward compatibility)업그레이드를 통해 프레임워크에 구형 메소드 호출과 구형 객체 전달을 지원할 것인가? 아니면 상위 호환성(forward compatibility)업그레이드를 통해 신형 스타일의 객체를 클라이언트에 전달해 동작하도록 할 것인가?  

## 라이브러리 클래스
(정적 메소드들의 집합, Util성 클래스인듯???)  
라이브러리 클래스를 사용하면 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.  
새로운 버전의 라이브러리 클래스를 릴리즈 하는 경우에도 기존 메소드가 이전과 같이 동작하는지만 확인하면 된다.  
ex) Collections 클래스: 새로운 버전의 라이브러리 클래스에서는 기존 기능을 그대로 나둔 채 새로운 정적 메소드를 추가한다.  

## 객체
프레임워크를 객체로 나타내는 경우, 단순성과 복잡성 사이, 유연성과 구체성 사이에서 균형을 잡기는 더욱 어려워진다.  
프레임워크는 클라이언트에게 유용하고 안정적이면서 프레임워크 개발자에게는 발전시키기 쉬워야 한다.  
클라이언트가 프레임워크의 바뀌지 않을 것 같은 부분에만 의존적으로 코드를작성하자.  
  
프레임워크를 객체로 나타낼 때에는 네 가지 이슈가 있다.
 - 사용 스타일: 클라이언트가 프레임워크 객체를 인스턴스화해서 사용할 것인가 아니면 확장시켜서(상속) 사용할 것인가?
 - 추상화: 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가? 상대적으로 안정적인 세부 사항에 대해 어떤 가시성을 사용할 것인가?
 - 생성: 어떻게 객체를 생성하는가?
 - 메소드: 메소드를 어떻게 구성하면 클라이언트에게는 유용성을, 프레임워크 개발자에게는 유연성을 제공할 수 있을까?

### 사용 스타일
프레임워크는 인스턴스화, 설정, 구현의 세 가지 주요 스타일을 지원한다.  
가장 단순한 스타일은 인스턴스화이다. 서버 소켓을 사용하고 싶다면 new ServerSocket()을 사용하면 된다. 클라이언트가 로직의 변형을 필요로 하지 않고 데이터의 변형만을 필요로 하는 경우 인스턴스화를 사용하라.  

설정은 인스턴스화보다 복잡하지만 좀더 유연하다. 예를들면.. 
```java
// TreeSet은 클라이언트에서 정의하는 Comparator를 사용해서 원소 사이의 정렬을 수행한다.
Comparator<Author> byFirstName = new Comparator<Author>() {
	public int compare(Author book1, Author book2) {
		return book1.getFirstName().compareTo(book2.getFirstName());
	}
};
SortedSet<Author> sorted = new TreeSet<Author>(byFirstName);
```
설정은 데이터뿐 아니라 로직의 변형도 지원하므로 인스턴스화보다 유연하다. 그러나 설정을 사용해서 클라이언트 객체를 호출하는 경우, 계속해서 같은 인터페이스를 사용해야 하므로 프레임워크를 발전시키는 데 제한이 생기고 클라이언트 코드에 대한 호환성을 보장해주기 어려워진다.  
또한 실질적으로 표현할 수 있는 변형의 종류에도 제한이 있다. 예를 들어 어떤 객체 설정에 2개 이상의 옵션이 들어가는 경우 클라이언트가 쉽게 사용할 수 없을것.  
  
클라이언트가 설정에서 제공하는 것 이상으로 많은 종류의 로직의 변형을 필요로 하는 경우, 구현에 의한 상요을 제공할 수 있다. 이 경우 클라이언트는 프레임워크에서 사용할 클래스르를 생성해서 프레임워크에 전달한다.  
클라이언트 클래스가 프레임워크의 클래스나 인터페이스를 확장하거나 구현하는 한 클라이언트는 어떤 로직이라도 사용할 수 있다.    
  
객체를 사용하는 세 가지 스타일 중에서 구현은 미래에 있을 설계 변경을 가장 크게 제한한다. 호환성을 보장하기 위해서는 프레임워크에서 제공하는 상위클래스나 인터페이스를 그대로 유지해야 하기 때문이다.  
프레임워크 추상화에서 세부 사항을 노출하는것은 양날의 검. 이를 통해 클라이언트는 자신의 코드를 사용할 수 있게 되지만, 프레임워크 개발자는 기존 클라이언트 코드와의 호환성을 포기하지 않는 이상 앞으로도 같은 인터페이스를 계속 사용해야 하기 떄문이다.  
  
구현 스타일은 설정에 비해 표현할 수 있는 범위가 훨씬 넓다. 필요한 경우 프레임워크에서 제공하는 메소드에 원하는 변형만을 구현하면 되기 때문이다.  


































